# Generated by Django 5.2.8 on 2025-11-28

import uuid

import django.db.models.deletion
from django.db import migrations, models


def consolidate_question_storage(apps, schema_editor):
    InterviewForm = apps.get_model("form_ai", "InterviewForm")
    InterviewQuestion = apps.get_model("form_ai", "InterviewQuestion")
    TechnicalAssessment = apps.get_model("form_ai", "TechnicalAssessment")
    AssessmentQuestion = apps.get_model("form_ai", "AssessmentQuestion")
    CandidateAnswer = apps.get_model("form_ai", "CandidateAnswer")
    AssessmentQuestionBank = apps.get_model("form_ai", "AssessmentQuestionBank")

    def build_entry(instance, payload, sequence):
        payload = payload or {}
        return {
            "id": str(getattr(instance, "id", uuid.uuid4())),
            "sequence_number": sequence,
            "text": (payload.get("text") or payload.get("question") or "").strip(),
            "type": payload.get("type") or payload.get("question_type") or "text",
            "metadata": payload.get("metadata") or {},
            "options": payload.get("options") or [],
        }

    # Interview forms -> inline question schema
    for form in InterviewForm.objects.all():
        rows = (
            InterviewQuestion.objects.filter(form=form)
            .order_by("sequence_number", "id")
            .all()
        )
        entries = [
            build_entry(
                question, getattr(question, "question_payload", {}), question.sequence_number
            )
            for question in rows
        ]
        form.question_schema = entries
        form.save(update_fields=["question_schema"])

    # Technical assessments -> inline question schema
    for assessment in TechnicalAssessment.objects.all():
        rows = (
            AssessmentQuestion.objects.filter(assessment=assessment)
            .order_by("sequence_number", "id")
            .all()
        )
        entries = [
            build_entry(
                question, getattr(question, "question_payload", {}), question.sequence_number
            )
            for question in rows
        ]
        assessment.question_schema = entries
        assessment.save(update_fields=["question_schema"])

    # Candidate answers -> one row per assessment
    answers_by_assessment = {}
    candidate_rows = (
        CandidateAnswer.objects.select_related("question", "question__assessment")
        .exclude(question__isnull=True)
        .all()
    )

    for answer in candidate_rows:
        question = answer.question
        assessment = question.assessment
        if not assessment:
            continue
        answers_map = answers_by_assessment.setdefault(assessment.id, {})
        text = (answer.response_text or "").strip() or "NIL"
        answers_map[f"q{question.sequence_number}"] = text
        answers_map[str(question.id)] = text

    for assessment_id, answers_map in answers_by_assessment.items():
        candidates = (
            CandidateAnswer.objects.filter(question__assessment_id=assessment_id)
            .order_by("id")
            .all()
        )
        if not candidates:
            continue
        keeper = candidates[0]
        keeper.assessment_id = assessment_id
        keeper.response_text = ""
        keeper.answers = answers_map
        keeper.save(update_fields=["assessment", "response_text", "answers"])
        extra_ids = [candidate.pk for candidate in candidates[1:]]
        if extra_ids:
            CandidateAnswer.objects.filter(pk__in=extra_ids).delete()

    CandidateAnswer.objects.filter(assessment__isnull=True).delete()

    # Question bank -> collapse per role
    role_rows: dict[str, list[tuple[int, dict]]] = {}
    for row in AssessmentQuestionBank.objects.all().order_by("role", "sequence_number"):
        payload = getattr(row, "question_payload", {})
        role_rows.setdefault(row.role, []).append(
            (row.id, build_entry(row, payload, getattr(row, "sequence_number", 1)))
        )

    for role, rows in role_rows.items():
        rows.sort(key=lambda item: item[1]["sequence_number"] or 0)
        keeper = AssessmentQuestionBank.objects.filter(role=role).order_by("id").first()
        if not keeper:
            continue
        keeper.questions = [entry for _, entry in rows]
        keeper.save(update_fields=["questions"])
        extra_ids = [row_id for row_id, _ in rows[1:]]
        if extra_ids:
            AssessmentQuestionBank.objects.filter(id__in=extra_ids).delete()


class Migration(migrations.Migration):

    dependencies = [
        ("form_ai", "0005_remove_assessmentquestion_question_text_and_more"),
    ]

    operations = [
        migrations.AddField(
            model_name="interviewform",
            name="question_schema",
            field=models.JSONField(
                blank=True,
                default=list,
                help_text="Ordered question definitions stored inline (JSON list of {id, sequence_number, text, type, metadata, options})",
            ),
        ),
        migrations.AddField(
            model_name="technicalassessment",
            name="question_schema",
            field=models.JSONField(
                blank=True,
                default=list,
                help_text="Ordered question definitions stored inline (JSON list of {id, sequence_number, text, type, metadata, options})",
            ),
        ),
        migrations.AddField(
            model_name="assessmentquestionbank",
            name="updated_at",
            field=models.DateTimeField(auto_now=True),
        ),
        migrations.AddField(
            model_name="assessmentquestionbank",
            name="questions",
            field=models.JSONField(
                blank=True,
                default=list,
                help_text="Ordered question payloads maintained inline",
            ),
        ),
        migrations.AddField(
            model_name="candidateanswer",
            name="answers",
            field=models.JSONField(
                blank=True,
                default=dict,
                help_text="Question ID/sequence mapped to normalized answer text",
            ),
        ),
        migrations.AddField(
            model_name="candidateanswer",
            name="assessment",
            field=models.OneToOneField(
                blank=True,
                help_text="Parent technical assessment",
                null=True,
                on_delete=django.db.models.deletion.CASCADE,
                related_name="answer_sheet",
                to="form_ai.technicalassessment",
            ),
        ),
        migrations.RunPython(
            consolidate_question_storage, migrations.RunPython.noop
        ),
        migrations.RemoveField(
            model_name="technicalassessment",
            name="qa_snapshot",
        ),
        migrations.AlterModelOptions(
            name="assessmentquestionbank",
            options={
                "ordering": ["role"],
                "verbose_name": "Assessment Question Bank",
                "verbose_name_plural": "Assessment Question Bank",
            },
        ),
        migrations.AlterUniqueTogether(
            name="assessmentquestionbank",
            unique_together=set(),
        ),
        migrations.AlterModelOptions(
            name="candidateanswer",
            options={
                "verbose_name": "Candidate Answer Sheet",
                "verbose_name_plural": "Candidate Answer Sheets",
            },
        ),
        migrations.AlterField(
            model_name="assessmentquestionbank",
            name="role",
            field=models.CharField(
                help_text="Role or position (e.g., Python Intern, Backend Developer)",
                max_length=255,
                unique=True,
            ),
        ),
        migrations.RemoveField(
            model_name="assessmentquestionbank",
            name="question_payload",
        ),
        migrations.RemoveField(
            model_name="assessmentquestionbank",
            name="sequence_number",
        ),
        migrations.RemoveField(
            model_name="candidateanswer",
            name="question",
        ),
        migrations.RemoveField(
            model_name="candidateanswer",
            name="response_text",
        ),
        migrations.DeleteModel(
            name="AssessmentQuestion",
        ),
        migrations.DeleteModel(
            name="InterviewQuestion",
        ),
    ]
